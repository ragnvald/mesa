# In general - Do not make changes to the configuration file.
# Changes could lead to the program not working as expected.

[DEFAULT]
input_folder_asset              = input/asset
input_folder_geocode            = input/geocode
input_folder_lines              = input/lines
input_folder_atlas              = input/atlas
input_folder_evaluate_landuse   = input/evaluate_landuse
input_folder_images             = input/images
output_folder                   = output/
gpkg_file = output/mesa.gpkg

mesa_version                    = 5.0 beta 2025-12-26
# Themes: cosmo, flatly, journal, litera, lumen, minty, pulse,
# sandstone, united, yeti, morph, simplex, cerculan, solar, superhero, darkly, cyborg, vapor
ttk_bootstrap_theme             = litera

# OpenAI-key used for intellingent processing
openai_api_key_file             = secrets/openai.key

# Asset lines and points minimum buffer as we do not relate to arealess features.
default_line_buffer_m           = 10
default_point_buffer_m          = 10

# MBtileset zoom levels. This defines the zoom levels for which tiles will be 
# generated. The higher the zoom level, the more detailed the tiles will be, but
# also the larger the file size. Processing time and storage requirements will
# increase with higher zoom levels.
tiles_minzoom                   = 6
tiles_maxzoom                   = 12

# Performance knobs
# These settings influence speed, memory use, and how often the UI/log gets updates
# during heavy processing (intersections, tiling, etc.). Typical errors which indicate
# memory issues (e.g., "bad allocation" or similar) can often be resolved by lowering
# the geocode_soft_limit and asset_soft_limit values.
#
# Notes:
# - Smaller limits typically reduce peak memory, but can increase overhead and runtime.
# - More frequent progress/heartbeat updates can make the UI feel more responsive, but
#   may slow processing slightly.
# - If you are unsure: keep defaults.
#
#
# Worker processes for CPU-side parallel work: 0=auto. Final worker count is still capped by RAM budget (see approx_gb_per_worker/mem_target_frac) and CPU count.
max_workers                     = 0
# Cap for H3 generation: if estimated H3 cells for the AOI exceed this, H3 levels are skipped to avoid extreme time/RAM use.
h3_max_cells                    = 20000000

# -------------------------------------------------------------------------
# Basic mosaic (basic_mosaic) performance knobs
# These only affect the “Create geocodes (H3 / Mosaic)” mosaic build.
#
# Key idea:
# - The slow phase is "Parallel boundary extraction". If CPU looks low near the
#   end, it is often because only a few heavy chunks remain ("straggler tail").
#   Use task ordering + smaller chunk sizes to keep workers busy.

# Force mosaic generation to run single-process.
# - false: use multiprocessing when mosaic_workers > 1 (default)
# - true: force workers=1 (lower peak RAM; slower)
mosaic_force_serial             = false

# Number of worker processes for mosaic boundary extraction.
# - 0: auto-size based on CPU and available RAM (default)
# - N>0: fixed number of worker processes
mosaic_workers                  = 0

# Auto worker sizing (only used when mosaic_workers = 0)
# - fraction: fraction of detected CPUs to consider
mosaic_auto_worker_fraction     = 0.75
# - min: minimum workers when auto-sizing
mosaic_auto_worker_min          = 1
# - max: 0 means no explicit upper bound (still capped by RAM); otherwise cap workers
mosaic_auto_worker_max          = 0
# - mem_gb: approximate GB per worker used for RAM-based capping
mosaic_auto_worker_mem_gb       = 1.5

# Enable multiprocessing for boundary extraction.
# - true: use multiprocessing pool (default)
# - false: always run extraction serially (easier debugging; slower)
mosaic_parallel_extract         = true

# Chunk size for parallel boundary extraction.
# - Larger: less overhead, but worse load balancing (can create a slow tail)
# - Smaller: better load balancing, but more overhead
mosaic_extract_chunk_size       = 2500

# Task ordering for parallel chunks (reduces end-of-run stalls).
# - interleave: mix light/heavy chunks for steadier progress (default)
# - heavy_first: run heaviest chunks first
# - light_first: run lightest chunks first
mosaic_task_order               = interleave

# Pool dispatch chunk size for imap_unordered (NOT the same as mosaic_extract_chunk_size).
# - 1: most responsive/steady (default)
# - >1: lower overhead but can worsen load balance
mosaic_extract_pool_chunksize   = 1

# Restart each worker after N tasks (limits memory growth; too small adds overhead).
# - 0/empty is not allowed; use >= 1
# - Typical: 10–50 on Windows for large projects
mosaic_extract_maxtasksperchild = 4

# Advanced (leave defaults unless tuning)
# Batch sizes for union reduction stages.
mosaic_line_union_batch         = 4000
mosaic_line_union_max_partials  = 16
mosaic_coverage_union_batch     = 500

# Flush polygonize output to disk every N faces (reduces peak RAM).
mosaic_faces_flush_batch        = 250000

# Compatibility note:
# Older configs used mosaic_pool_maxtasksperchild / mosaic_pool_chunksize.
# Newer builds prefer mosaic_extract_maxtasksperchild / mosaic_extract_pool_chunksize.
# Both are accepted; keep only one set to avoid confusion.

# -------------------------------------------------------------------------
# Processing (data_process) performance knobs
# These settings affect the main processing pipeline (intersections, chunking,
# flattening, and related heavy steps run by tools\data_process.exe).

# Update progress/UI every N tiles (smaller = more updates, slightly slower)
tiles_progress_every            = 1000
# If a chunk contains more than this many geocodes, processing will split work to keep memory stable
geocode_soft_limit              = 400
# If a chunk contains more than this many assets, processing will split work to keep memory stable
asset_soft_limit                = 50000
# Estimated RAM use per worker (GB). Higher value => fewer workers chosen when max_workers=0
approx_gb_per_worker            = 5.0
# Fraction of available RAM to treat as usable budget when auto-sizing work (0.0-1.0)
mem_target_frac                 = 0.95
# Seconds between “still working” pings in long-running operations (smaller = more frequent logs)
heartbeat_secs                  = 60
# Base processing chunk size (feature count). Smaller reduces peak memory but increases overhead/runtime.
chunk_size                      = 20000
# Spatial grid cell size used when partitioning work. Smaller can reduce peak memory (more partitions) but may run slower.
cell_size                       = 9000

# Basemap provider for report maps:
# - xyz (default): Use MESA's built-in OSM XYZ downloader with persistent cache under output/tile_cache
# - contextily: Use contextily (if installed); no tiles stored under output/tile_cache
# - auto: Prefer contextily, fall back to xyz
report_basemap_mode             = xyz

# Inset styling for report maps (context insets, overview insets)
report_inset_border_color       = #1f1f1f
report_inset_border_lw          = 1.2
report_inset_shadow_alpha       = 0.18
report_inset_shadow_dx          = 0.006
report_inset_shadow_dy          = 0.008

# Default sizes for atlases
atlas_lon_size_km               = 100
atlas_lat_size_km               = 100
atlas_overlap_percent           = 10

# Default segment sizes for line segmentation
segment_width                   = 600
segment_length                  = 1000

# Projection used to calculate areas and distances.
area_projection_epsg            = 3035
# Projection used for working calculations (e.g., buffering, intersections)
working_projection_epsg         = 4326
# Projection used for output data
output_projection_epsg          = 4326


[A]
range                           = 21-25
description                     = Very high
category_colour                 = #bd0026

[B]
range                           = 16-20
description                     = High
category_colour                 = #f03b20

[C]
range                           = 11-15
description                     = Moderate
category_colour                 = #fd8d3c

[D]
range                           = 6-10
description                     = Low
category_colour                 = #fecc5c

[E]
range                           = 1-5
description                     = Very low
category_colour                 = #ffffb2

[VALID_VALUES]
valid_input                     = 1,2,3,4,5
category_colour_unknown         = #BDBDBD
index_importance_weights = 1,2,5,5,10
index_sensitivity_weights = 10,10,10,10,10,10,10,10,10,10,10,10,10,10
